/* eslint-disable */
// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async addWorldToFolder(
    folderName: string,
    worldId: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('add_world_to_folder', {
          folderName,
          worldId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async removeWorldFromFolder(
    folderName: string,
    worldId: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('remove_world_from_folder', {
          folderName,
          worldId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async hideWorld(worldId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('hide_world', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async unhideWorld(worldId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('unhide_world', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getFolders(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_folders') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createFolder(name: string): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_folder', { name }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async deleteFolder(name: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_folder', { name }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async moveFolder(
    folderName: string,
    newIndex: number,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('move_folder', { folderName, newIndex }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async renameFolder(
    oldName: string,
    newName: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('rename_folder', { oldName, newName }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getWorlds(
    folderName: string,
  ): Promise<Result<WorldDisplayData[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_worlds', { folderName }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getAllWorlds(): Promise<Result<WorldDisplayData[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_all_worlds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getUnclassifiedWorlds(): Promise<Result<WorldDisplayData[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_unclassified_worlds'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getHiddenWorlds(): Promise<Result<WorldDisplayData[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_hidden_worlds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getTagsByCount(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_tags_by_count') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getAuthorsByCount(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_authors_by_count') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async deleteWorld(worldId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_world', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getTheme(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_theme') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getLanguage(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_language') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getCardSize(): Promise<Result<CardSize, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_card_size') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async tryLogin(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('try_login') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async loginWithCredentials(
    username: string,
    password: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('login_with_credentials', {
          username,
          password,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async loginWith2fa(
    code: string,
    twoFactorType: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('login_with_2fa', { code, twoFactorType }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async logout(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('logout') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getFavoriteWorlds(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_favorite_worlds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getWorld(
    worldId: string,
    dontSaveToLocal: boolean | null,
  ): Promise<Result<WorldDetails, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_world', { worldId, dontSaveToLocal }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async checkWorldInfo(worldId: string): Promise<Result<WorldDetails, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('check_world_info', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getRecentlyVisitedWorlds(): Promise<
    Result<WorldDisplayData[], string>
  > {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_recently_visited_worlds'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async searchWorlds(
    sort: string,
    tag: string,
    search: string,
    page: number,
  ): Promise<Result<WorldDisplayData[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('search_worlds', { sort, tag, search, page }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createWorldInstance(
    worldId: string,
    instanceTypeStr: string,
    regionStr: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_world_instance', {
          worldId,
          instanceTypeStr,
          regionStr,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getUserGroups(): Promise<Result<UserGroup[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_user_groups') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getPermissionForCreateGroupInstance(
    groupId: string,
  ): Promise<Result<GroupInstancePermissionInfo, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_permission_for_create_group_instance', {
          groupId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createGroupInstance(
    worldId: string,
    groupId: string,
    instanceTypeStr: string,
    allowedRoles: string[] | null,
    regionStr: string,
    queueEnabled: boolean,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_group_instance', {
          worldId,
          groupId,
          instanceTypeStr,
          allowedRoles,
          regionStr,
          queueEnabled,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async fetchPatreonData(): Promise<Result<PatreonData, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('fetch_patreon_data') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Checks if the app is being run for the first time
   * As this is called every time / is loaded from the frontend, cache result in the state
   */
  async requireInitialSetup(): Promise<boolean> {
    return await TAURI_INVOKE('require_initial_setup');
  },
  /**
   * Checks if files have been loaded from disk successfully
   *
   * # Returns
   * Returns a boolean indicating if the files have been loaded successfully
   *
   * # Errors
   * Returns a tuple containing a boolean indicating if the files have been loaded, and an error message
   */
  async checkFilesLoaded(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('check_files_loaded') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async detectOldInstallation(): Promise<Result<[string, string], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('detect_old_installation'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Passes the paths to the frontend
   * Gets the path to the local app data directory
   *
   * # Returns
   * Returns the path to the local app data directory
   *
   * # Errors
   * Returns an error message if the path to the local app data directory could not be found
   */
  async passPaths(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('pass_paths') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async checkExistingData(): Promise<Result<[boolean, boolean], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('check_existing_data') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getBackupMetadata(
    backupPath: string,
  ): Promise<Result<BackupMetaData, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_backup_metadata', { backupPath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getMigrationMetadata(
    worldsPath: string,
    foldersPath: string,
  ): Promise<Result<PreviousMetadata, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_migration_metadata', {
          worldsPath,
          foldersPath,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createEmptyAuth(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('create_empty_auth') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createEmptyFiles(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('create_empty_files') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setPreferences(
    theme: string,
    language: string,
    cardSize: CardSize,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_preferences', {
          theme,
          language,
          cardSize,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createBackup(backupPath: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_backup', { backupPath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async restoreFromBackup(backupPath: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('restore_from_backup', { backupPath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async migrateOldData(
    worldsPath: string,
    foldersPath: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('migrate_old_data', {
          worldsPath,
          foldersPath,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async deleteData(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('delete_data') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type BackupMetaData = {
  date: string;
  number_of_folders: number;
  number_of_worlds: number;
  app_version: string;
};
export type CardSize = 'Compact' | 'Normal' | 'Expanded' | 'Original';
export type GroupInstanceCreateAllowedType = {
  normal: boolean;
  plus: boolean;
  public: boolean;
  restricted: boolean;
};
export type GroupInstanceCreatePermission =
  | { Allowed: GroupInstanceCreateAllowedType }
  | 'NotAllowed';
export type GroupInstancePermissionInfo = {
  permission: GroupInstanceCreatePermission;
  roles: GroupRole[];
};
export type GroupMemberVisibility = 'visible' | 'friends' | 'hidden';
export type GroupPermission =
  | '*'
  | 'group-announcement-manage'
  | 'group-audit-view'
  | 'group-bans-manage'
  | 'group-data-manage'
  | 'group-default-role-manage'
  | 'group-galleries-manage'
  | 'group-instance-age-gated-create'
  | 'group-instance-join'
  | 'group-instance-manage'
  | 'group-instance-moderate'
  | 'group-instance-open-create'
  | 'group-instance-plus-create'
  | 'group-instance-plus-portal'
  | 'group-instance-plus-portal-unlocked'
  | 'group-instance-public-create'
  | 'group-instance-queue-priority'
  | 'group-instance-restricted-create'
  | 'group-invites-manage'
  | 'group-members-manage'
  | 'group-members-remove'
  | 'group-members-viewall'
  | 'group-roles-assign'
  | 'group-roles-manage';
export type GroupRole = {
  id: string;
  groupId: string;
  name: string;
  permissions: GroupPermission[];
  isManagementRole: boolean;
};
export type PatreonData = {
  platinumSupporter: string[];
  goldSupporter: string[];
  silverSupporter: string[];
  bronzeSupporter: string[];
  basicSupporter: string[];
};
export type Platform = 'PC' | 'Quest' | 'Cross-Platform';
export type PreviousMetadata = {
  number_of_folders: number;
  number_of_worlds: number;
};
export type UserGroup = {
  id: string;
  name: string;
  shortCode: string;
  discriminator: string;
  description: string;
  iconUrl?: string | null;
  bannerUrl?: string | null;
  privacy: string;
  memberCount: number;
  groupId: string;
  memberVisibility: GroupMemberVisibility;
  isRepresenting: boolean;
  mutualGroup: boolean;
};
export type WorldDetails = {
  worldId: string;
  name: string;
  thumbnailUrl: string;
  authorName: string;
  authorId: string;
  favorites: number;
  lastUpdated: string;
  visits: number;
  platform: Platform;
  description: string;
  tags: string[];
  capacity: number;
  recommendedCapacity: number | null;
  publicationDate: string | null;
};
export type WorldDisplayData = {
  worldId: string;
  name: string;
  thumbnailUrl: string;
  authorName: string;
  favorites: number;
  lastUpdated: string;
  visits: number;
  dateAdded: string;
  platform: Platform;
  folders: string[];
  tags: string[];
};

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from '@tauri-apps/api/core';
import * as TAURI_API_EVENT from '@tauri-apps/api/event';
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow';

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: 'ok'; data: T }
  | { status: 'error'; error: E };

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>;
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    },
  );
}

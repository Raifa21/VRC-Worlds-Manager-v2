/* eslint-disable */
// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async fetchPatreonData(): Promise<Result<PatreonData, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('fetch_patreon_data') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async fetchBlacklist(): Promise<Result<WorldBlacklist, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('fetch_blacklist') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getChangelog(): Promise<Result<LocalizedChanges[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_changelog') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getTaskStatus(id: string): Promise<Result<TaskStatus, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_task_status', { id }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async cancelTaskRequest(id: string): Promise<Result<TaskStatus, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('cancel_task_request', { id }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getTaskError(id: string): Promise<Result<string | null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_task_error', { id }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async checkForUpdate(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('check_for_update') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async downloadUpdate(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('download_update') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async installUpdate(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('install_update') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async doNotNotifyUpdate(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('do_not_notify_update') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async addWorldToFolder(
    folderName: string,
    worldId: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('add_world_to_folder', {
          folderName,
          worldId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async removeWorldFromFolder(
    folderName: string,
    worldId: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('remove_world_from_folder', {
          folderName,
          worldId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async hideWorld(worldId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('hide_world', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async unhideWorld(worldId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('unhide_world', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getFolders(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_folders') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createFolder(name: string): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_folder', { name }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async deleteFolder(name: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_folder', { name }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async moveFolder(
    folderName: string,
    newIndex: number,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('move_folder', { folderName, newIndex }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async renameFolder(
    oldName: string,
    newName: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('rename_folder', { oldName, newName }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getWorlds(
    folderName: string,
  ): Promise<Result<WorldDisplayData[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_worlds', { folderName }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getAllWorlds(): Promise<Result<WorldDisplayData[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_all_worlds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getUnclassifiedWorlds(): Promise<Result<WorldDisplayData[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_unclassified_worlds'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getHiddenWorlds(): Promise<Result<WorldDisplayData[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_hidden_worlds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getTagsByCount(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_tags_by_count') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getAuthorsByCount(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_authors_by_count') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async deleteWorld(worldId: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_world', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getFoldersForWorld(worldId: string): Promise<Result<string[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_folders_for_world', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async shareFolder(folderName: string): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('share_folder', { folderName }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async updateFolderShare(
    folderName: string,
  ): Promise<Result<string | null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_folder_share', { folderName }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Downloads a shared folder and adds its worlds to the local database.
   *
   * This function attempts to download a folder using the provided `share_id`, creates the folder locally,
   * adds the worlds from the shared folder to the local world list, and then adds all non-hidden worlds to the new folder.
   * Worlds that are already hidden are not added to the folder and are returned for further handling.
   *
   * # Arguments
   *
   * * `share_id` - The identifier of the shared folder to download.
   *
   * # Returns
   *
   * `Ok((String, Vec<String>))`: A tuple containing the new folder name and a vector of world IDs that were hidden and not added to the folder.
   *
   * # Errors
   * Returns an error string if any operation fails, such as downloading the folder, creating the folder, adding worlds, or retrieving hidden worlds.
   */
  async downloadFolder(
    shareId: string,
  ): Promise<Result<[string, WorldDisplayData[]], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('download_folder', { shareId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getTheme(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_theme') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setTheme(theme: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('set_theme', { theme }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getLanguage(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_language') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setLanguage(language: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_language', { language }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getCardSize(): Promise<Result<CardSize, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_card_size') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setCardSize(cardSize: CardSize): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_card_size', { cardSize }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getRegion(): Promise<Result<InstanceRegion, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_region') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setRegion(region: InstanceRegion): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_region', { region }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getStarredFilterItems(
    id: FilterItemSelectorStarredType,
  ): Promise<Result<string[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_starred_filter_items', { id }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setStarredFilterItems(
    id: FilterItemSelectorStarredType,
    values: string[],
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_starred_filter_items', { id, values }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getFolderRemovalPreference(): Promise<
    Result<FolderRemovalPreference, string>
  > {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_folder_removal_preference'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setFolderRemovalPreference(
    dontShowRemoveFromFolder: FolderRemovalPreference,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_folder_removal_preference', {
          dontShowRemoveFromFolder,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getUpdateChannel(): Promise<Result<UpdateChannel, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_update_channel') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setUpdateChannel(
    channel: UpdateChannel,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_update_channel', { channel }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async tryLogin(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('try_login') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async loginWithCredentials(
    username: string,
    password: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('login_with_credentials', {
          username,
          password,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async loginWith2fa(
    code: string,
    twoFactorType: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('login_with_2fa', { code, twoFactorType }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async logout(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('logout') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getFavoriteWorlds(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_favorite_worlds') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getWorld(
    worldId: string,
    dontSaveToLocal: boolean | null,
  ): Promise<Result<WorldDetails, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_world', { worldId, dontSaveToLocal }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async checkWorldInfo(worldId: string): Promise<Result<WorldDetails, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('check_world_info', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getRecentlyVisitedWorlds(): Promise<
    Result<WorldDisplayData[], string>
  > {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_recently_visited_worlds'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async searchWorlds(
    sort: string,
    tags: string[],
    excludeTags: string[],
    search: string,
    page: number,
  ): Promise<Result<WorldDisplayData[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('search_worlds', {
          sort,
          tags,
          excludeTags,
          search,
          page,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createWorldInstance(
    worldId: string,
    instanceTypeStr: string,
    regionStr: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_world_instance', {
          worldId,
          instanceTypeStr,
          regionStr,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getUserGroups(): Promise<Result<UserGroup[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_user_groups') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getPermissionForCreateGroupInstance(
    groupId: string,
  ): Promise<Result<GroupInstancePermissionInfo, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_permission_for_create_group_instance', {
          groupId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createGroupInstance(
    worldId: string,
    groupId: string,
    instanceTypeStr: string,
    allowedRoles: string[] | null,
    regionStr: string,
    queueEnabled: boolean,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_group_instance', {
          worldId,
          groupId,
          instanceTypeStr,
          allowedRoles,
          regionStr,
          queueEnabled,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async openLogsDirectory(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_logs_directory') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async openFolderDirectory(): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('open_folder_directory'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Checks if the app is being run for the first time
   * As this is called every time / is loaded from the frontend, cache result in the state
   */
  async requireInitialSetup(): Promise<boolean> {
    return await TAURI_INVOKE('require_initial_setup');
  },
  /**
   * Checks if files have been loaded from disk successfully
   *
   * # Returns
   * Returns a boolean indicating if the files have been loaded successfully
   *
   * # Errors
   * Returns a tuple containing a boolean indicating if the files have been loaded, and an error message
   */
  async checkFilesLoaded(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('check_files_loaded') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async detectOldInstallation(): Promise<Result<[string, string], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('detect_old_installation'),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  /**
   * Passes the paths to the frontend
   * Gets the path to the local app data directory
   *
   * # Returns
   * Returns the path to the local app data directory
   *
   * # Errors
   * Returns an error message if the path to the local app data directory could not be found
   */
  async passPaths(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('pass_paths') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async checkExistingData(): Promise<Result<[boolean, boolean], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('check_existing_data') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getBackupMetadata(
    backupPath: string,
  ): Promise<Result<BackupMetaData, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_backup_metadata', { backupPath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getMigrationMetadata(
    worldsPath: string,
    foldersPath: string,
  ): Promise<Result<PreviousMetadata, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_migration_metadata', {
          worldsPath,
          foldersPath,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createEmptyAuth(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('create_empty_auth') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createEmptyFiles(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('create_empty_files') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async createBackup(backupPath: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_backup', { backupPath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async restoreFromBackup(backupPath: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('restore_from_backup', { backupPath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async migrateOldData(
    worldsPath: string,
    foldersPath: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('migrate_old_data', {
          worldsPath,
          foldersPath,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async deleteData(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('delete_data') };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async getMemo(worldId: string): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_memo', { worldId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async setMemoAndSave(
    worldId: string,
    memo: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_memo_and_save', { worldId, memo }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
  async searchMemoText(searchText: string): Promise<Result<string[], string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('search_memo_text', { searchText }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: 'error', error: e as any };
    }
  },
};

/** user-defined events **/

export const events = __makeEvents__<{
  taskStatusChanged: TaskStatusChanged;
  updateProgress: UpdateProgress;
}>({
  taskStatusChanged: 'task-status-changed',
  updateProgress: 'update-progress',
});

/** user-defined constants **/

/** user-defined types **/

export type BackupMetaData = {
  date: string;
  number_of_folders: number;
  number_of_worlds: number;
  app_version: string;
};
export type CardSize = 'Compact' | 'Normal' | 'Expanded' | 'Original';
export type FilterItemSelectorStarredType =
  | 'Author'
  | 'Tag'
  | 'ExcludeTag'
  | 'Folder';
export type FolderRemovalPreference = 'ask' | 'alwaysRemove' | 'neverRemove';
export type GroupInstanceCreateAllowedType = {
  normal: boolean;
  plus: boolean;
  public: boolean;
  restricted: boolean;
};
export type GroupInstanceCreatePermission =
  | { Allowed: GroupInstanceCreateAllowedType }
  | 'NotAllowed';
export type GroupInstancePermissionInfo = {
  permission: GroupInstanceCreatePermission;
  roles: GroupRole[];
};
export type GroupMemberVisibility = 'visible' | 'friends' | 'hidden';
export type GroupPermission =
  | '*'
  | 'group-announcement-manage'
  | 'group-audit-view'
  | 'group-bans-manage'
  | 'group-data-manage'
  | 'group-default-role-manage'
  | 'group-galleries-manage'
  | 'group-instance-age-gated-create'
  | 'group-instance-join'
  | 'group-instance-manage'
  | 'group-instance-moderate'
  | 'group-instance-open-create'
  | 'group-instance-plus-create'
  | 'group-instance-plus-portal'
  | 'group-instance-plus-portal-unlocked'
  | 'group-instance-public-create'
  | 'group-instance-queue-priority'
  | 'group-instance-restricted-create'
  | 'group-invites-manage'
  | 'group-members-manage'
  | 'group-members-remove'
  | 'group-members-viewall'
  | 'group-roles-assign'
  | 'group-roles-manage';
export type GroupRole = {
  id: string;
  groupId: string;
  name: string;
  permissions: GroupPermission[];
  isManagementRole: boolean;
};
export type InstanceRegion = 'us' | 'use' | 'eu' | 'jp';
export type LocalizedChanges = {
  version: string;
  pre_release: boolean;
  features: string[];
  fixes: string[];
  others: string[];
};
export type PatreonData = {
  platinumSupporter: string[];
  goldSupporter: string[];
  silverSupporter: string[];
  bronzeSupporter: string[];
  basicSupporter: string[];
};
export type Platform = 'PC' | 'Quest' | 'Cross-Platform';
export type PreviousMetadata = {
  number_of_folders: number;
  number_of_worlds: number;
};
export type TaskStatus = 'Running' | 'Completed' | 'Cancelled' | 'Failed';
export type TaskStatusChanged = { id: string; status: TaskStatus };
export type UpdateChannel = 'stable' | 'pre-release';
export type UpdateProgress = { progress: number };
export type UserGroup = {
  id: string;
  name: string;
  shortCode: string;
  discriminator: string;
  description: string;
  iconUrl?: string | null;
  bannerUrl?: string | null;
  privacy: string;
  memberCount: number;
  groupId: string;
  memberVisibility: GroupMemberVisibility;
  isRepresenting: boolean;
  mutualGroup: boolean;
};
export type WorldBlacklist = { worlds: string[] };
export type WorldDetails = {
  worldId: string;
  name: string;
  thumbnailUrl: string;
  authorName: string;
  authorId: string;
  favorites: number;
  lastUpdated: string;
  visits: number;
  platform: Platform;
  description: string;
  tags: string[];
  capacity: number;
  recommendedCapacity: number | null;
  publicationDate: string | null;
};
export type WorldDisplayData = {
  worldId: string;
  name: string;
  thumbnailUrl: string;
  authorName: string;
  favorites: number;
  lastUpdated: string;
  visits: number;
  dateAdded: string;
  platform: Platform;
  folders: string[];
  tags: string[];
  capacity: number;
};

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from '@tauri-apps/api/core';
import * as TAURI_API_EVENT from '@tauri-apps/api/event';
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow';

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: 'ok'; data: T }
  | { status: 'error'; error: E };

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>;
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    },
  );
}
